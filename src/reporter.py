import pandas as pd
import xlsxwriter
from xlsxwriter.utility import xl_range
from typing import List, Dict

class FinancialReporter:
    def __init__(self, output_path: str):
        self.output_path = output_path
        self.writer = pd.ExcelWriter(output_path, engine='xlsxwriter')
        self.workbook = self.writer.book
        
        # --- Define Styles ---
        self.header_format = self.workbook.add_format({
            'bold': True, 
            'text_wrap': True, 
            'valign': 'vcenter', 
            'align': 'center',
            'fg_color': '#4F81BD', 
            'font_color': 'white',
            'border': 1
        })
        
        self.metric_name_format = self.workbook.add_format({
            'bold': True,
            'border': 1,
            'bg_color': '#F2F2F2'
        })
        
        self.currency_format = self.workbook.add_format({
            'num_format': '#,##0', 
            'border': 1
        })
        
        self.percent_format = self.workbook.add_format({
            'num_format': '0.0%', 
            'border': 1
        })
        
        self.text_format = self.workbook.add_format({'border': 1})
        
        self.title_format = self.workbook.add_format({
            'bold': True, 
            'font_size': 16,
            'font_color': '#366092'
        })
        
        self.subtitle_format = self.workbook.add_format({
            'italic': True, 
            'font_size': 11,
            'font_color': '#595959'
        })
        
        # Conditional formatting style (Red text/bg for negative)
        self.neg_format = self.workbook.add_format({
            'font_color': '#9C0006', 
            'bg_color': '#FFC7CE'
        })

    def determine_format(self, metric_name: str):
        """Returns the appropriate Excel format based on the metric name."""
        lower_name = metric_name.lower()
        if any(x in lower_name for x in ['margin', 'growth', 'ratio', 'roe']):
            return self.percent_format
        return self.currency_format

    def create_dashboard(self, df: pd.DataFrame, company_info: Dict):
        worksheet = self.workbook.add_worksheet('Dashboard')
        
        # Hide gridlines for a cleaner look
        worksheet.hide_gridlines(2)
        
        # 1. Prepare Data for Transposition
        # Ensure 'period_end_date' is available and convert to Year
        if 'period_end_date' in df.columns:
            df['Year'] = pd.to_datetime(df['period_end_date']).dt.year
        else:
            # Fallback if no date column (unlikely)
            df['Year'] = range(len(df))
            
        # Filter out metadata columns to keep only metrics
        metadata_cols = ['period_end_date', 'company_name', 'currency', 'reporting_unit', 'Year']
        metric_cols = [c for c in df.columns if c not in metadata_cols]
        
        # Transpose: Index=Metrics, Columns=Years
        # Set index to Year, select metric cols, then Transpose
        df_transposed = df.set_index('Year')[metric_cols].T
        
        # Sort columns (Years) Ascending (Oldest -> Newest) for logical reading
        df_transposed = df_transposed.sort_index(axis=1)
        
        # 2. Write Headers (Company Info)
        company_name = company_info.get('company_name', 'Unknown Company')
        currency = company_info.get('currency', 'N/A')
        unit = company_info.get('reporting_unit', 'thousands')
        
        worksheet.write('B2', f"{company_name} - Financial Dashboard", self.title_format)
        worksheet.write('B3', f"Reporting Currency: {currency} (in {unit}) | Generated by Financial Agent", self.subtitle_format)
        
        # 3. Write Table Header (Years)
        start_row = 5
        start_col = 1 # Column B
        
        # Write "Metric" Header
        worksheet.write(start_row, start_col, "Metric", self.header_format)
        
        # Write Year Headers
        years = df_transposed.columns.tolist()
        for i, year in enumerate(years):
            worksheet.write(start_row, start_col + 1 + i, str(year), self.header_format)
            
        # Write "Trend (5Y)" Header
        trend_col = start_col + 1 + len(years)
        worksheet.write(start_row, trend_col, "Trend", self.header_format)
        
        # 4. Write Data Rows
        for i, (metric, row_data) in enumerate(df_transposed.iterrows()):
            current_row = start_row + 1 + i
            
            # Write Metric Name
            display_name = metric.replace('_', ' ').title()
            worksheet.write(current_row, start_col, display_name, self.metric_name_format)
            
            # Determine format
            cell_format = self.determine_format(metric)
            
            # Write values
            row_values = row_data.tolist()
            for j, val in enumerate(row_values):
                col_idx = start_col + 1 + j
                if pd.isna(val):
                    worksheet.write(current_row, col_idx, "-", self.text_format)
                else:
                    worksheet.write(current_row, col_idx, val, cell_format)
            
            # 5. Add Sparklines
            # Range of data for this row
            # Note: Sparklines work best with continuous data.
            if len(years) > 1:
                data_range = xl_range(current_row, start_col + 1, current_row, start_col + len(years))
                
                worksheet.add_sparkline(current_row, trend_col, {
                    'range': data_range,
                    'type': 'line',
                    'style': 12, # Blue line
                    'markers': True
                })
                # Add border to sparkline cell
                worksheet.write(current_row, trend_col, "", self.text_format)
            else:
                worksheet.write(current_row, trend_col, "N/A", self.text_format)

        # 6. Conditional Formatting (Negative Values)
        # Apply to the data block
        first_data_row = start_row + 1
        last_data_row = start_row + len(df_transposed)
        first_data_col = start_col + 1
        last_data_col = start_col + len(years)
        
        if last_data_col >= first_data_col:
            worksheet.conditional_format(first_data_row, first_data_col, last_data_row, last_data_col,
                                         {'type': 'cell',
                                          'criteria': '<',
                                          'value': 0,
                                          'format': self.neg_format})
                                      
        # 7. Adjust Column Widths
        worksheet.set_column(start_col, start_col, 30) # Metric Name
        worksheet.set_column(first_data_col, last_data_col, 15) # Data Columns
        worksheet.set_column(trend_col, trend_col, 15) # Trend Column
        
        # Close
        try:
            self.writer.close()
            print(f"Excel dashboard saved to: {self.output_path}")
        except PermissionError:
            print(f"‚ö†Ô∏è Permission denied: Could not write to {self.output_path}. File might be open.")
            new_path = self.output_path.replace(".xlsx", "_new.xlsx")
            print(f"üîÑ Saving to alternative path: {new_path}")
            self.writer = pd.ExcelWriter(new_path, engine='xlsxwriter')
            self.workbook = self.writer.book
            # Re-create dashboard since writer was reset (simplified approach: just warn and fail for now, 
            # or better: we need to re-run the whole create_dashboard logic if we reset writer.
            # Since we can't easily re-run create_dashboard without passing data again, let's just raise 
            # but suggest closing the file. 
            # ACTUALLY, we can't just change the path on the existing writer object easily if it's already initialized.
            # We have to re-initialize.
            pass
            raise PermissionError(f"Could not save to {self.output_path}. Please close the file and try again.")

def generate_excel_report(df: pd.DataFrame, output_path: str) -> str:
    """
    Wrapper function to maintain compatibility with main.py.
    Instantiates FinancialReporter and creates the dashboard.
    """
    if df.empty:
        print("Warning: DataFrame is empty. Skipping Excel generation.")
        return
        
    # Extract company info from the first row of the DataFrame
    company_info = {
        'company_name': df['company_name'].iloc[0] if 'company_name' in df.columns else 'Unknown Company',
        'currency': df['currency'].iloc[0] if 'currency' in df.columns else 'N/A',
        'reporting_unit': df['reporting_unit'].iloc[0] if 'reporting_unit' in df.columns else 'thousands'
    }
    
    try:
        reporter = FinancialReporter(output_path)
        reporter.create_dashboard(df, company_info)
        return output_path
    except PermissionError:
        print(f"‚ö†Ô∏è Permission denied: {output_path} is open.")
        new_path = output_path.replace(".xlsx", f"_{pd.Timestamp.now().strftime('%H%M%S')}.xlsx")
        print(f"üîÑ Retrying with new filename: {new_path}")
        reporter = FinancialReporter(new_path)
        reporter.create_dashboard(df, company_info)
        return new_path

if __name__ == "__main__":
    # Test block
    from datetime import date
    
    data = {
        'period_end_date': [date(2024, 12, 31), date(2023, 12, 31), date(2022, 12, 31)],
        'company_name': ['CD PROJEKT', 'CD PROJEKT', 'CD PROJEKT'],
        'currency': ['PLN', 'PLN', 'PLN'],
        'revenue': [985030, 1230199, 800000],
        'revenue_growth_yoy': [-0.19, 0.53, 0.1],
        'ebit': [365496, 469040, 300000],
        'ebit_margin': [0.37, 0.38, 0.375],
        'net_income': [469874, 481105, 350000],
        'net_income_growth_yoy': [-0.02, 0.37, 0.1],
        'net_margin': [0.47, 0.39, 0.43],
        'assets': [3042424, 2613500, 2000000],
        'equity': [2800667, 2403223, 1800000],
        'roe': [0.16, 0.20, 0.19]
    }
    df = pd.DataFrame(data)
    generate_excel_report(df, "test_dashboard.xlsx")
